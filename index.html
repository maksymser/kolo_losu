<!DOCTYPE html>
<html lang="pl">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link href='https://fonts.googleapis.com/css?family=Boldonse&display=swap' rel='stylesheet'>
  <link rel="preload" href="https://fonts.googleapis.com/css?family=Boldonse" as="style">
  <title>KOŁO LOSU (Wersja HTML/CSS)</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      height: 100%;
      background: transparent;
      font-family: 'Boldonse';
    }
    #overlay {
      position: fixed;
      top: 0; left: 0; right: 0; bottom: 0;
      background: transparent;
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    #wheel-container, #jackpot-wheel-container {
      position: relative;
      width: 90vmin;
      height: 90vmin;
      border-radius: 50%;
      box-shadow: 0 0 20px rgba(255,255,255,0.2);
      border: 8px solid #444;
      background: transparent;
      overflow: hidden; /* Zmienione z 'visible' na 'hidden' dla koła CSS */
      display: flex;
      justify-content: center;
      align-items: center;
      transition: opacity 0.5s;
    }

    /* NOWY STYL DLA KOŁA HTML/CSS */
    .wheel-core {
      position: relative;
      width: 100%;
      height: 100%;
      border-radius: 50%;
      box-shadow: inset 0 0 15px rgba(0,0,0,0.7);
      
      /* To jest serce animacji obrotu. Długi czas i easing. */
      transition: transform 7000ms cubic-bezier(.17,.86,.34,.99);
      
      /* Tło będzie ustawione przez JS (conic-gradient) */
    }
    .wheel-segments-container {
      position: absolute;
      top: 0; left: 0; right: 0; bottom: 0;
      border-radius: 50%;
    }
    .wheel-segment {
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      border-radius: 50%;
    }
    .segment-text {
      position: absolute;
      top: 5%; /* Odległość tekstu od krawędzi */
      left: 50%;
      transform: translateX(-50%);
      transform-origin: center;
      font-size: 14px; /* Rozmiar tekstu na kole */
      font-weight: bold;
      color: white;
      text-shadow: 0 0 3px #000;
      text-align: center;
      max-width: 40%;
      line-height: 1.2;
      /* Tekst jest obrócony o 90 stopni, aby leżał wzdłuż promienia */
      transform: translateX(-50%) rotate(90deg);
      user-select: none;
    }
    /* Koniec nowych stylów */
    
    #pointer, #jackpot-pointer {
      position: absolute;
      top: 50%;
      left: 97%;
      transform: translateY(-50%);
      width: 7vmin;
      height: 5vmin;
      background: linear-gradient(90deg, #fcff9e 0%, #c67700 100%);
      clip-path: polygon(0 50%, 100% 75%, 100% 25%);
      box-shadow: 0 0 10px #fff;
      z-index: 1100;
      pointer-events: none;
      transition: filter 0.12s;
    }
    #pointer.bounce, #jackpot-pointer.bounce {
      animation: pointerTick 0.2s;
      transform-origin: 0% 50%;
    }
    @keyframes pointerTick {
      0% { transform: translateY(-50%) rotate(0deg); }
      50% { transform: translateY(-50%) rotate(10deg); }
      100% { transform: translateY(-50%) rotate(0deg); }
    }
    #countdown {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 10vmin;
      color: white;
      opacity: 0;
      pointer-events: none;
      font-weight: bold;
      text-shadow: 0 0 25px #000, 0 0 5px #fff;
      transition: opacity 0.3s;
    }
    #label {
      position: absolute;
      bottom: -10px;
      width: auto;
      padding: 8px 20px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 12px;
      text-align: center;
      font-size: 4vmin;
      color: white;
      font-weight: bold;
      user-select: none;
      letter-spacing: 0.2em;
      text-shadow: 0 0 8px #000, 0 0 2px #fff;
      margin: 0 auto;
      left: 50%;
      z-index: 1301;
      transform: translateX(-50%);
      transition: opacity 0.3s;
    }
    #result-message {
      position: fixed;
      top: 40%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 5vmin;
      background: rgba(0,0,0,0.9);
      padding: 30px 40px;
      border-radius: 18px;
      text-align: center;
      z-index: 1300;
      box-shadow: 0 0 40px #000, 0 0 10px #ffd700;
      font-weight: bold;
      text-shadow: 0 0 12px #000, 0 0 2px #fff;
    }
    #result-gif {
      position: fixed;
      top: 75%;
      left: 50%;
      transform: translate(-50%, -50%);
      max-width: 15vw;
      max-height: 15vh;
      z-index: 3001;
      border-radius: 12px;
      box-shadow: 0 0 30px #000, 0 0 10px #fff;
      background: #222;
      padding: 4px;
    }
    #spin-button, #jackpot-spin-button {
      position:absolute;
      top:50%;left:50%;
      transform:translate(-50%, -50%);
      width:120px;height:120px;
      opacity:0.04;
      border:none;
      background:none;
      cursor:pointer;
      z-index:1200;
    }
    #restart-button {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 200px;
      height: 200px;
      background: #fff;
      opacity: 0.04;
      border: none;
      cursor: pointer;
      z-index: 9999;
      display: none;
      border-radius: 50%;
    }
    #jackpot-glow {
      position: absolute;
      top: 25%;
      left: 50%;
      transform: translate(-50%,-50%);
      font-size: 8vmin;
      color: #ff2222;
      -webkit-text-stroke: 1px #650d0d;    
      font-weight: bold;
      text-shadow:
        0 0 30px #ff0000,
        0 0 60px #ff2222,
        0 0 100px #fff,
        0 0 10px #fff;
      animation: jackpotGlow 1.2s infinite alternate;
      z-index: 1300;
      pointer-events: none;
      letter-spacing: 0.1em;
      user-select: none;
    }
    @keyframes jackpotGlow {
      0% { text-shadow: 0 0 10px #ff0000, 0 0 30px #fff;}
      100% { text-shadow: 0 0 40px #ff0000, 0 0 100px #fff;}
    }
    .jackpot-light {
      position: absolute;
      width: 34px; height: 34px;
      border-radius: 50%;
      background: #360000;
      box-shadow: 0 0 10px #000;
      transition: background 0.1s, box-shadow 0.1s;
      z-index: 1250;
    }
    .jackpot-light.on {
      background: #ff1111;
      box-shadow: 0 0 24px #ff2222, 0 0 60px #ff0000;
    }
    .shimmer {
      animation: shimmer 1s linear infinite;
    }
    @keyframes shimmer {
      0% { filter: brightness(1.2) drop-shadow(0 0 10px #fff9); }
      50% { filter: brightness(1.7) drop-shadow(0 0 30px #fff6); }
      100% { filter: brightness(1.2) drop-shadow(0 0 10px #fff9); }
    }
    .jackpot-lights-blink {
      animation: jackpotLightsBlink 0.1s infinite alternate;
    }
    @keyframes jackpotLightsBlink {
      0% { 
        background: #ff1111;
        box-shadow: 0 0 24px #ff2222, 0 0 60px #ff0000;
      }
      100% { 
        background: #360000;
        box-shadow: 0 0 10px #000;
      }
    }
  </style>
</head>
<body>
<div id="overlay">
  <div id="wheel-container">
    <div id="wheel" class="wheel-core">
      <div class="wheel-segments-container">
        </div>
    </div>
    <div id="pointer"></div>
    <button id="spin-button"></button>
    <div id="countdown"></div>
    <div id="label">KOŁO LOSU</div>
  </div>
  
  <div id="jackpot-wheel-container" style="display:none;">
    <div id="jackpot-wheel" class="wheel-core">
      <div class="wheel-segments-container">
        </div>
    </div>
    <div id="jackpot-pointer"></div>
    <button id="jackpot-spin-button"></button>
    <div id="jackpot-glow">JACKPOT</div>
    <div id="label">KOŁO LOSU</div>
  </div>
</div>
<button id="restart-button"></button>

<script>
document.addEventListener('DOMContentLoaded', () => {
  try {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    isAudioInitialized = true;
  } catch (e) {
    console.log('Audio nie może być zainicjalizowane automatycznie');
  }
});

const prizes = [
  { name: "Nic xd", probability: 0.08, type: "regular", color: "linear-gradient(135deg, #8e44ad, #3498db)", gif: "https://cdn.7tv.app/emote/01F38SGEQG000AG1XYT03162S8/4x.avif" },
  { name: "Stanie na głowie", probability: 0.10, type: "regular", color: "linear-gradient(135deg, #1d976c, #93f9b9)", gif: "https://www.healthshots.com/wp-content/uploads/2019/12/Yoga-headstand.gif" },
  { name: "Timeout 1h dla wybranego widza", probability: 0.08, type: "regular", color: "linear-gradient(135deg, #009fff, #ec2f4b)", gif: "https://cdn.7tv.app/emote/01H1848QNG0005EZED5J0EYKHR/4x.webp" },
  { name: "Krzyczę BOKS - STOP", probability: 0.08, type: "regular", color: "linear-gradient(135deg, #ff512f, #dd2476)", gif: "https://cdn.7tv.app/emote/01G3SCEE20000AVHF824CCM0DA/4x.avif" },
  { name: "Nic xd", probability: 0.05, type: "regular", color: "linear-gradient(135deg, #8e44ad, #3498db)", gif: "https://cdn.7tv.app/emote/01G6SRPZ400006H81S3K13JY36/4x.webp" },
  { name: "Piję łyka wody (lub Dzika®)", probability: 0.08, type: "regular", color: "linear-gradient(135deg, #3F2B96, #A8C0FF)", gif: "https://cdn.7tv.app/emote/01GCWH9E9R000D8RDSXFWM2GBA/4x.avif" },
  { name: "10 pompek", probability: 0.08, type: "regular", color: "linear-gradient(135deg, #fc466b, #3f5efb)", gif: "https://cdn.7tv.app/emote/01F6R3WYDR000B7RB73RKS83AK/4x.avif" },
  { name: "Nie odzywam się przez 2 minuty", probability: 0.08, type: "regular", color: "linear-gradient(135deg, #00C9FF, #92FE9D)", gif: "https://cdn.7tv.app/emote/01GYZBC7FR0006TGDMK2MFGXGW/4x.webp" },
  { name: "Stoję w miejscu przez minutę", probability: 0.08, type: "regular", color: "linear-gradient(135deg, #4b6cb7, #182848)", gif: "https://cdn.7tv.app/emote/01GNQJGTSG00078AS6P1AC892Q/4x.webp" },
  { name: "krzycze ło tego", probability: 0.08, type: "regular", color: "linear-gradient(135deg, #8e44ad, #3498db)", gif: "https://cdn.7tv.app/emote/01H1AAGAGR0003C6C0Q3R0B0VX/4x.avif" },
  { name: "Nic xd", probability: 0.08, type: "regular", color: "linear-gradient(135deg, #8e44ad, #3498db)", gif: "https://cdn.7tv.app/emote/01FZ975PV8000B4AWRZNMVNEXN/4x.avif" },
  { name: "Mówię głosem dziwki przez 2 minuty", probability: 0.08, type: "regular", color: "linear-gradient(135deg, #BB377D, #FBD3E9)", gif: "https://media1.tenor.com/m/1SPr0yOrWdgAAAAd/paprikafume-slay-queen.gif" },  
  { name: "tts dla wszystkich na 2 minuty", probability: 0.03, type: "regular", color: "linear-gradient(135deg, #BB377D, #FBD3E9)", gif: "https://media1.tenor.com/m/1SPr0yOrWdgAAAAd/paprikafume-slay-queen.gif" }, 
  { name: "JACKPOT", probability: 0.02, type: "jackpot", color: "gold", gif: "" }
];
const jackpotPrizes = [
  { name: "wale jajo na łeb", probability: 0.3, type: "special", color: "linear-gradient(135deg, #ffe898, #57370e)", gif: "https://cdn.7tv.app/emote/01H8CPJG9R0009CBM9NXZQY8HT/4x.avif" },
  { name: "zerowanie piwa", probability: 0.3, type: "special", color: "linear-gradient(135deg, #ffe898, #57370e)", gif: "https://cdn.7tv.app/emote/01H8CPJG9R0009CBM9NXZQY8HT/4x.avif" },
  { name: "VIP", probability: 0.2, type: "special", color: "linear-gradient(135deg, #ffe898, #57370e)", gif: "https://cdn.7tv.app/emote/01G3E8EC580004KFXXGTW7QDKM/4x.avif" },
  { name: "STREAM 24H!!!", probability: 0.2, type: "special", color: "linear-gradient(135deg, #ffe898, #57370e)", gif: "https://cdn.7tv.app/emote/01J0KSR6D0000CV45TECHJ0JRZ/4x.avif" }
];
const jackpotLightsCount = 30; 
let spinning = false;
let selectedPrizeIndex = null;
let selectedJackpotIndex = null;
let isJackpotPhase = false;
let currentAngle = 0, jackpotCurrentAngle = 0;
let resultTimeout = null;
let resultGif = null;

let audioContext = null;
let isAudioInitialized = false;

let jackpotLightInterval = null;
let currentLightIndex = 0;
let tickInterval = null; // Do symulowania dźwięku tykania

let prevSeg = { m: -1, j: -1 };

// Funkcje audio i TTS (bez zmian)
function initAudio() {
  if (!isAudioInitialized) {
    try {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
      if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => { console.log('Audio context odblokowany'); });
      }
      isAudioInitialized = true;
    } catch (e) { console.log('Web Audio API nie jest obsługiwane'); }
  }
}
function forceAudioInit() {
  initAudio();
  if (audioContext && audioContext.state === 'suspended') {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
    oscillator.start();
    oscillator.stop(audioContext.currentTime + 0.01);
  }
}
function playCountdownSound() {
  if (!audioContext) return;
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  oscillator.frequency.setValueAtTime(400, audioContext.currentTime);
  oscillator.type = 'sine';
  gainNode.gain.setValueAtTime(0, audioContext.currentTime);
  gainNode.gain.linearRampToValueAtTime(0.1, audioContext.currentTime + 0.01);
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.3);
  oscillator.start(audioContext.currentTime);
  oscillator.stop(audioContext.currentTime + 0.3);
}
function playTickSound() {
  if (!audioContext) return;
  const oscillator = audioContext.createOscillator();
  const gainNode = audioContext.createGain();
  oscillator.connect(gainNode);
  gainNode.connect(audioContext.destination);
  oscillator.frequency.setValueAtTime(800, audioContext.currentTime);
  oscillator.type = 'square';
  gainNode.gain.setValueAtTime(0, audioContext.currentTime);
  gainNode.gain.linearRampToValueAtTime(0.05, audioContext.currentTime + 0.005);
  gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 0.1);
  oscillator.start(audioContext.currentTime);
  oscillator.stop(audioContext.currentTime + 0.1);
}
function playRegularWinSound() {
  if (!audioContext) return;
  const melodies = [
    [659.25, 783.99, 880, 783.99, 659.25, 880, 1046.50],
    [530.81, 596, 530.81, 564.81, 596, 530.81, 661.63],
    [482.41, 498, 516.54, 546.83, 574.61, 510, 530.81, 564.81]
  ];
  const selectedMelody = melodies[Math.floor(Math.random() * melodies.length)];
  const noteDuration = 0.16;
  selectedMelody.forEach((frequency, index) => {
    const startTime = audioContext.currentTime + index * noteDuration;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    osc.frequency.setValueAtTime(frequency, startTime);
    osc.type = 'sine';
    gain.gain.setValueAtTime(0, startTime);
    gain.gain.linearRampToValueAtTime(0.12, startTime + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, startTime + noteDuration - 0.01);
    osc.start(startTime);
    osc.stop(startTime + noteDuration);
  });
}
function playSpecialWinSound() {
  if (!audioContext) return;
  const melody = [ 440, 523.25, 659.26, 783.99, 1046.5, 1318.5, 1568, 2093, 2637, 2093, 1568, 1318.5, 1046.5, 1568, 2093, 1568, 2093, 1568, 2093, 1568, 1568, 2093, 1568 ];
  const noteDuration = 0.12;
  melody.forEach((frequency, index) => {
    const startTime = audioContext.currentTime + index * noteDuration;
    const osc = audioContext.createOscillator();
    const gain = audioContext.createGain();
    osc.connect(gain);
    gain.connect(audioContext.destination);
    osc.frequency.setValueAtTime(frequency, startTime);
    osc.type = 'sawtooth';
    gain.gain.setValueAtTime(0, startTime);
    gain.gain.linearRampToValueAtTime(0.14, startTime + 0.01);
    gain.gain.exponentialRampToValueAtTime(0.001, startTime + noteDuration - 0.01);
    osc.start(startTime);
    osc.stop(startTime + noteDuration);
  });
}
function playJackpotSound() {
  if (!audioContext) return;
  const baseFreq = 261.63; 
  const frequencies = [baseFreq, baseFreq * 1.25, baseFreq * 1.5, baseFreq * 2]; 
  frequencies.forEach((freq, index) => {
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();
    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);
    oscillator.frequency.setValueAtTime(freq, audioContext.currentTime);
    oscillator.type = 'sawtooth';
    gainNode.gain.setValueAtTime(0, audioContext.currentTime);
    gainNode.gain.linearRampToValueAtTime(0.08, audioContext.currentTime + 0.1);
    gainNode.gain.exponentialRampToValueAtTime(0.001, audioContext.currentTime + 1.5);
    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 1.5);
  });
  setTimeout(() => {
    const melody = [523.25, 659.25, 783.99, 1046.50, 783.99, 1046.50]; 
    melody.forEach((frequency, index) => {
      const startTime = audioContext.currentTime + index * 0.15;
      const oscillator = audioContext.createOscillator();
      const gainNode = audioContext.createGain();
      oscillator.connect(gainNode);
      gainNode.connect(audioContext.destination);
      oscillator.frequency.setValueAtTime(frequency, startTime);
      oscillator.type = 'triangle';
      gainNode.gain.setValueAtTime(0, startTime);
      gainNode.gain.linearRampToValueAtTime(0.12, startTime + 0.01);
      gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + 0.14);
      oscillator.start(startTime);
      oscillator.stop(startTime + 0.15);
    });
  }, 300);
}
let selectedVoice = null;
function initTTS() {
  if (speechSynthesis.getVoices().length === 0) {
    speechSynthesis.addEventListener('voiceschanged', () => { selectPolishVoice(); });
  } else { selectPolishVoice(); }
}
function selectPolishVoice() {
  const voices = speechSynthesis.getVoices();
  selectedVoice = voices.find(voice => 
    voice.lang.includes('pl') || voice.name.toLowerCase().includes('polish') ||
    voice.name.toLowerCase().includes('paulina') || voice.name.toLowerCase().includes('zofia')
  );
  if (!selectedVoice && voices.length > 0) { selectedVoice = voices[0]; }
  console.log('Wybrany głos TTS:', selectedVoice?.name || 'Brak dostępnych głosów');
}
function speakText(text) {
  if ('speechSynthesis' in window) {
    speechSynthesis.cancel();
    const utterance = new SpeechSynthesisUtterance(text);
    if (selectedVoice) { utterance.voice = selectedVoice; }
    utterance.rate = 1.35; 
    utterance.pitch = 0.75; 
    utterance.volume = 0.95; 
    speechSynthesis.speak(utterance);
  } else { console.log('TTS nie jest obsługiwane w tej przeglądarce'); }
}

// *** NOWA LOGIKA BUDOWANIA KOŁA ***

// Ta funkcja buduje tło koła (conic-gradient) na podstawie prawdopodobieństw
function generateConicGradientString(prizesArr) {
  let gradientString = 'conic-gradient(';
  let currentAngle = 0;
  
  // Oblicz sumę prawdopodobieństw (na wypadek gdyby nie sumowały się do 1)
  const totalProb = prizesArr.reduce((sum, p) => sum + p.probability, 0);

  prizesArr.forEach(prize => {
    const angle = (prize.probability / totalProb) * 360;
    const color = (prize.color === 'gold') ? '#ffd700' : prize.color;
    gradientString += `${color} ${currentAngle}deg ${currentAngle + angle}deg, `;
    currentAngle += angle;
  });

  // Usuń ostatni przecinek i spację
  gradientString = gradientString.slice(0, -2);
  gradientString += ')';
  
  return gradientString;
}

// Ta funkcja buduje segmenty koła (teksty)
function buildWheel(prizesArr, wheelId) {
  const wheelElement = document.getElementById(wheelId);
  if (!wheelElement) return;

  const segmentsContainer = wheelElement.querySelector('.wheel-segments-container');
  segmentsContainer.innerHTML = ''; // Wyczyść stare segmenty

  // 1. Ustaw tło (gradient)
  wheelElement.style.background = generateConicGradientString(prizesArr);

  // 2. Stwórz i dodaj etykiety tekstowe
  let accumulatedAngle = 0;
  const totalProb = prizesArr.reduce((sum, p) => sum + p.probability, 0);

  prizesArr.forEach(prize => {
    const angle = (prize.probability / totalProb) * 360;
    const middleAngle = accumulatedAngle + (angle / 2); // Kąt do środka segmentu

    const segmentDiv = document.createElement('div');
    segmentDiv.className = 'wheel-segment';
    // Obracamy cały segment, aby tekst był na środku
    segmentDiv.style.transform = `rotate(${middleAngle}deg)`;

    const textDiv = document.createElement('div');
    textDiv.className = 'segment-text';
    textDiv.textContent = prize.name;
    
    // Specjalna obsługa "JACKPOT"
    if (prize.type === 'jackpot') {
      textDiv.style.color = '#000';
      textDiv.style.textShadow = '0 0 3px #fff';
      textDiv.style.fontSize = '18px';
    }

    segmentDiv.appendChild(textDiv);
    segmentsContainer.appendChild(segmentDiv);

    accumulatedAngle += angle;
  });
}

// *** ZMODYFIKOWANA LOGIKA OBROTU ***

// Funkcja losująca (bez zmian)
function selectPrizeByProbability(arr, lastIdx) {
  let selected = -1;
  let attempts = 0; 
  while (attempts < 5) { 
    let r = Math.random();
    let sum = 0;
    for (let i = 0; i < arr.length; i++) {
      sum += arr[i].probability;
      if (r <= sum) { selected = i; break; }
    }
    if (selected === -1) selected = arr.length - 1;
    if (arr.length <= 1 || selected !== lastIdx) break; 
    attempts++;
  }
  return selected;
}

// Funkcja symulująca "tykanie" i podskok wskaźnika
function simulateTick() {
  playTickSound();
  const pointer = isJackpotPhase ? document.getElementById('jackpot-pointer') : document.getElementById('pointer');
  pointer.classList.remove('bounce');
  void pointer.offsetWidth; // force reflow
  pointer.classList.add('bounce');
}

// Główna funkcja obrotu
function spinWheel() {
  if (spinning) return;
  spinning = true;
  isJackpotPhase = false;
  
  const wheelElement = document.getElementById('wheel');
  document.getElementById('wheel-container').style.opacity = "1";
  document.getElementById('jackpot-wheel-container').style.display = "none";
  
  selectedPrizeIndex = selectPrizeByProbability(prizes, prevSeg.m);
  const totalProb = prizes.reduce((sum, p) => sum + p.probability, 0);
  
  let accumulatedAngle = 0;
  for(let i = 0; i <= selectedPrizeIndex; i++) {
    const angle = (prizes[i].probability / totalProb) * 360;
    if(i === selectedPrizeIndex) {
      accumulatedAngle += (angle / 2); // Celuj w środek
    } else {
      accumulatedAngle += angle;
    }
  }

  // Kąt docelowy. 360 - ... ponieważ CSS obraca zgodnie z zegarem, a my liczyliśmy kąty odwrotnie
  // Dodajemy też obroty (minRot) i odejmujemy kąt wskaźnika (90 stopni)
  const minRot = Math.floor(Math.random() * 5) + 6; // 6-10 pełnych obrotów
  const targetAngle = (minRot * 360) + 360 - accumulatedAngle - 90; // -90 bo wskaźnik jest na 90 stopniach
  const spinDuration = 6000 + Math.random() * 2000; // 6-8 sekund

  // Zresetuj pozycję, aby obrót był płynny z poprzedniego miejsca
  const currentRotation = currentAngle % 360;
  wheelElement.style.transition = 'none';
  wheelElement.style.transform = `rotate(${currentRotation}deg)`;
  
  // Wymuś odświeżenie stylu
  void wheelElement.offsetWidth;

  // Ustaw docelową animację
  wheelElement.style.transition = `transform ${spinDuration}ms cubic-bezier(.17,.86,.34,.99)`;
  wheelElement.style.transform = `rotate(${targetAngle}deg)`;

  currentAngle = targetAngle; // Zapisz nową pozycję

  // Uruchom symulowane tykanie
  if(tickInterval) clearInterval(tickInterval);
  tickInterval = setInterval(simulateTick, 150); // Dźwięk co 150ms

  // Pokaż wynik po zakończeniu animacji
  setTimeout(() => {
    spinning = false;
    clearInterval(tickInterval);
    setTimeout(()=>showResult(prizes[selectedPrizeIndex], false), 1000);
  }, spinDuration);
}

// Rozpoczęcie fazy jackpot
function startJackpotPhase() {
  isJackpotPhase = true;
  document.getElementById('wheel-container').style.opacity = "0";
  
  setTimeout(()=>{
    document.getElementById('wheel-container').style.display = "none";
    document.getElementById('jackpot-wheel-container').style.display = "block";
    document.getElementById('jackpot-wheel-container').style.opacity = "1";
    
    setupJackpotLights();

    const lights = Array.from(document.querySelectorAll('.jackpot-light'));
    if (jackpotLightInterval) clearInterval(jackpotLightInterval);
    currentLightIndex = 0;
    
    jackpotLightInterval = setInterval(() => {
      const prevIndex = (currentLightIndex === 0) ? lights.length - 1 : currentLightIndex - 1;
      if (lights[prevIndex]) { lights[prevIndex].classList.remove('on'); }
      if (lights[currentLightIndex]) { lights[currentLightIndex].classList.add('on'); }
      currentLightIndex = (currentLightIndex + 1) % jackpotLightsCount;
    }, 75);

    setTimeout(spinJackpotWheel, 700);
  }, 500);
}

// Obrót kołem jackpot
function spinJackpotWheel() {
  if (spinning) return;
  spinning = true;

  const wheelElement = document.getElementById('jackpot-wheel');
  selectedJackpotIndex = selectPrizeByProbability(jackpotPrizes, prevSeg.j);
  const totalProb = jackpotPrizes.reduce((sum, p) => sum + p.probability, 0);

  let accumulatedAngle = 0;
  for(let i = 0; i <= selectedJackpotIndex; i++) {
    const angle = (jackpotPrizes[i].probability / totalProb) * 360;
    if(i === selectedJackpotIndex) {
      accumulatedAngle += (angle / 2);
    } else {
      accumulatedAngle += angle;
    }
  }

  const minRot = Math.floor(Math.random() * 4) + 5; // 5-8 obrotów
  const targetAngle = (minRot * 360) + 360 - accumulatedAngle - 90;
  const spinDuration = 5000 + Math.random() * 2000; // 5-7 sekund

  const currentRotation = jackpotCurrentAngle % 360;
  wheelElement.style.transition = 'none';
  wheelElement.style.transform = `rotate(${currentRotation}deg)`;
  
  void wheelElement.offsetWidth;

  wheelElement.style.transition = `transform ${spinDuration}ms cubic-bezier(.17,.86,.34,.99)`;
  wheelElement.style.transform = `rotate(${targetAngle}deg)`;

  jackpotCurrentAngle = targetAngle;

  if(tickInterval) clearInterval(tickInterval);
  tickInterval = setInterval(simulateTick, 150);

  setTimeout(() => {
    spinning = false;
    clearInterval(tickInterval);
    setTimeout(()=>showResult(jackpotPrizes[selectedJackpotIndex], true), 1000);
  }, spinDuration);
}


// Funkcje świateł jackpot (bez zmian)
function setupJackpotLights() {
  const cont = document.getElementById('jackpot-wheel-container');
  if (!cont) return;
  Array.from(cont.querySelectorAll('.jackpot-light')).forEach(e => e.remove());
  const containerRect = cont.getBoundingClientRect();
  if (containerRect.width === 0) return; 
  const containerSize = Math.min(containerRect.width, containerRect.height);
  const radius = containerSize / 2 - 30; 
  const lightSize = containerSize * 0.04; 
  for (let i = 0; i < jackpotLightsCount; i++) {
    const angle = (2 * Math.PI * i / jackpotLightsCount) - Math.PI / 2;
    const x = containerSize / 2 + Math.cos(angle) * radius - lightSize / 2 - 5;
    const y = containerSize / 2 + Math.sin(angle) * radius - lightSize / 2;
    const div = document.createElement('div');
    div.className = 'jackpot-light';
    div.style.width = lightSize + 'px';
    div.style.height = lightSize + 'px';
    div.style.left = x + 'px';
    div.style.top = y + 'px';
    cont.appendChild(div);
  }
}

// Funkcje pokazywania wyniku i restartu (z drobnymi zmianami)
function showResult(prize, isJackpot) {
  if (isJackpot) {
    prevSeg.j = selectedJackpotIndex;
  } else if (prize.type === 'regular') {
    prevSeg.m = selectedPrizeIndex;
  }

  removeResult();
  const div = document.createElement('div');
  div.id = "result-message";
  div.textContent = prize.name;
  document.body.appendChild(div);
  
  if (prize.gif) {
    const img = document.createElement('img');
    img.id = "result-gif";
    img.src = prize.gif;
    document.body.appendChild(img);
    resultGif = img;
  }
  
  if (!isJackpot && prize.type === "jackpot") { playJackpotSound(); }
  else if (!isJackpot && prize.type === "regular") { playRegularWinSound(); }
  else if (isJackpot && prize.type === "special") { playSpecialWinSound(); }

  let ttsText = "";
  if (!isJackpot && prize.type === "jackpot") { ttsText = "DŻEKPOT! Przechodzę do losowania nagrody specjalnej!"; }
  else if (isJackpot) { ttsText = `Gratulacje! Wylosowano ${prize.name}!`; }
  else { ttsText = `Wylosowano ${prize.name}`; }
  
  setTimeout(() => { speakText(ttsText); }, 800);

  if (isJackpot || prize.type === 'regular') {
    document.querySelectorAll('#label').forEach(l => l.style.opacity = '0');
  }
  
  if (isJackpot) {
    if (jackpotLightInterval) clearInterval(jackpotLightInterval);
    const lights = Array.from(document.querySelectorAll('.jackpot-light'));
    lights.forEach(light => {
      light.classList.remove('on');
      light.classList.add('jackpot-lights-blink');
    });
    resultTimeout = setTimeout(() => { removeResult(); hideWheelSmoothly(); }, 10000);
  } else {
    resultTimeout = setTimeout(() => { removeResult(); hideWheelSmoothly(); }, 10000);
  }
  
  if (!isJackpot && prize.type === "jackpot") {
    setTimeout(()=>{ removeResult(); startJackpotPhase(); }, 1800);
  }
}

function removeResult() {
  if (document.getElementById('result-message')) document.getElementById('result-message').remove();
  if (resultGif && resultGif.parentNode) resultGif.remove();
  resultGif = null;
  if (resultTimeout) clearTimeout(resultTimeout);
}

function hideWheelSmoothly() {
  const wheelContainer = document.getElementById('wheel-container');
  const jackpotContainer = document.getElementById('jackpot-wheel-container');
  
  if (isJackpotPhase) {
    jackpotContainer.style.transition = 'opacity 1s ease';
    jackpotContainer.style.opacity = '0';
    setTimeout(() => {
      jackpotContainer.style.display = 'none';
      isJackpotPhase = false;
      document.querySelectorAll('#label').forEach(l => l.style.opacity = '1');
      setTimeout(() => { document.getElementById('restart-button').style.display = 'block'; }, 2000);
    }, 1000);
  } else {
    wheelContainer.style.transition = 'opacity 1s ease';
    wheelContainer.style.opacity = '0';
    setTimeout(() => {
      wheelContainer.style.display = 'none';
      document.querySelectorAll('#label').forEach(l => l.style.opacity = '1');
      setTimeout(() => { document.getElementById('restart-button').style.display = 'block'; }, 2000);
    }, 1000);
  }
}

function startCountdown() {
  document.getElementById('restart-button').style.display = 'none';
  initAudio();
  
  const cd = document.getElementById('countdown');
  let nums = [3,2,1];
  let idx = 0;
  function next() {
    if (idx >= nums.length) {
      cd.style.opacity = 0;
      setTimeout(spinWheel, 200);
      return;
    }
    cd.textContent = nums[idx];
    cd.style.opacity = 1;
    cd.style.transition = "opacity 0.4s";
    playCountdownSound();
    setTimeout(()=>{
      cd.style.opacity = 0;
      setTimeout(()=>{ idx++; next(); }, 400);
    }, 750);
  }
  next();
}

// Przyciski (bez zmian)
document.getElementById('spin-button').onclick = ()=>{ if (!spinning && !isJackpotPhase) spinWheel(); };
document.getElementById('jackpot-spin-button').onclick = ()=>{ if (!spinning && isJackpotPhase) spinJackpotWheel(); };
window.spinFromOverlay = ()=> { if (!spinning && !isJackpotPhase) spinWheel(); };
document.getElementById('jackpot-wheel-container').style.display = "none";
initTTS();

// Inicjalizacja przy ładowaniu strony
window.onload = async () => {
  forceAudioInit();
  
  const hiddenButton = document.createElement('button');
  hiddenButton.style.position = 'absolute';
  hiddenButton.style.left = '-9999px';
  hiddenButton.style.opacity = '0';
  document.body.appendChild(hiddenButton);
  setTimeout(() => { hiddenButton.click(); hiddenButton.remove(); }, 100);
  
  // Zrezygnowaliśmy z waitForFont, bo CSS sam obsłuży ładowanie
  
  // ZBUDUJ KOŁA
  buildWheel(prizes, 'wheel');
  buildWheel(jackpotPrizes, 'jackpot-wheel');
  
  // Logika ResizeObserver (bez zmian)
  const resizeObserver = new ResizeObserver(entries => {
    for (let entry of entries) {
      const containerWidth = entry.contentRect.width;
      setupJackpotLights();
      const newFontSize = containerWidth * 0.045;
      document.querySelectorAll('#label').forEach(label => {
        label.style.fontSize = `${newFontSize}px`;
      });
    }
  });
  const mainContainer = document.getElementById('wheel-container');
  if (mainContainer) {
    resizeObserver.observe(mainContainer);
    const initialWidth = mainContainer.offsetWidth;
    const newFontSize = initialWidth * 0.045;
    document.querySelectorAll('#label').forEach(label => {
        label.style.fontSize = `${newFontSize}px`;
    });
  }
  
  // Logika przycisku restartu (bez zmian)
  document.getElementById('restart-button').onclick = () => {
    if (spinning) return;
    document.getElementById('restart-button').style.display = 'none';
    document.getElementById('wheel-container').style.display = 'block';
    
    // Resetuj kąt koła natychmiast, bez animacji
    const wheelElement = document.getElementById('wheel');
    wheelElement.style.transition = 'none';
    wheelElement.style.transform = `rotate(${currentAngle % 360}deg)`;
    
    setTimeout(() => {
       document.getElementById('wheel-container').style.opacity = '1';
       setTimeout(startCountdown, 400);
    }, 10);
  };
  
  setTimeout(startCountdown, 400);
};
</script>
</body>
</html>
